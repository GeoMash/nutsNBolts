
$JSKK.Class.create
(
	{
		$namespace:	'$JSKK',
		$name:		'When_'
	}
)
(
	{},
	{
		timer:	null,
		items:
		{
			length:	0
		},
		init:	function()
		{
			this.timer=null;
			this.startTimer();
		},
		startTimer: function()
		{
			if (Object.isNull(this.timer))
			{
				this.timer=window.setInterval
				(
					function()
					{
						for (var item in this.items)
						{
							if (item=='length')continue;
							//Try to execute the condition.
							try
							{
								this[this.items[item].condition](this.items[item]);
							}
							//Catch any exceptions, remove the item, then release the exception so that we don't have this infinately executing.
							catch(e)
							{
								this.removeItem(this.items[item].id);
								throw e;
							}
						}
					}.bind(this),
					100
				);
			}
		},
		stopTimer: function()
		{
			window.clearInterval(this.timer);
			this.timer=null;
		},
		captureCondition: function(condition,id,args)
		{
			var	args		=$JSKK.toArray(args)
			if (args.length)
			{
				this.items[id].condition	=condition;
				this.items[id].callback		=args.shift();
				this.items[id].args			=args;
			}
			else
			{
				this.removeItem(id);
			}
		},
		addItem: function(scope,object)
		{
			var id=Math.round(Math.random()*1000000);
			this.items[id]=
			{
				id:			id,
				scope:		scope,
				object:		object,
				condition:	null,
				callback:	$JSKK.emptyFunction,
				args:		null
			};
			this.items.length++;
			if (this.items.length)
			{
				this.startTimer();
			}
			return id;
		},
		removeItem: function(id)
		{
			delete this.items[id];
			this.items.length--;
			if (!this.items.length)
			{
				this.stopTimer();
			}
		},
		assert: function(result,item)
		{
			if (result)
			{
				item.callback.apply(item.callback,item.args);
				this.removeItem(item.id);
			}
		},
		isDefined: function(item)
		{
			this.assert(Object.isDefined(item.scope[item.object]),item);
		},
		isUndefined: function(item)
		{
			this.assert(Object.isUndefined(item.scope[item.object]),item);
		},
		isTrue: function(item)
		{
			if (!Object.isFunction(item.scope))
			{
				this.assert((item.scope[item.object]===true),item);
			}
			else
			{
				this.assert((item.scope()===true),item);
			}
		},
		isFalse: function(item)
		{
			if (!Object.isFunction(item.scope))
			{
				this.assert((item.scope[item.object]===false),item);
			}
			else
			{
				this.assert((item.scope()===false),item);
			}
		},
		isBoolean: function(item)
		{
			this.assert(Object.isBoolean(item.scope[item.object]),item);
		},
		isFunction: function(item)
		{
			this.assert(Object.isFunction(item.scope[item.object]),item);
		},
		isArray: function(item)
		{
			this.assert(Object.isArray(item.scope[item.object]),item);
		},
		isAssocArray: function(item)
		{
			this.assert(Object.isAssocArray(item.scope[item.object]),item);
		},
		isString: function(item)
		{
			this.assert(Object.isString(item.scope[item.object]),item);
		},
		isNumber: function(item)
		{
			this.assert(Object.isNumber(item.scope[item.object]),item);
		},
		isElement: function(item)
		{
			this.assert(Object.isElement(item.scope[item.object]),item);
		},
		isNull: function(item)
		{
			this.assert(Object.isNull(item.scope[item.object]),item);
		},
		isEqualTo: function(item)
		{
			this.assert((item.scope[item.object.object]==item.object.value),item);
		},
		isNotEqualTo: function(item)
		{
			this.assert((item.scope[item.object.object]!=item.object.value),item);
		}
	}
);
$JSKK.When=new $JSKK.When_();
$JSKK.when=function(scope,object)
{
	var	id		=$JSKK.When.addItem(scope,object),
		callee	=arguments.callee,
		chain	=
		{
			andWhen: function()
			{
				if (!arguments.length)
				{
					return callee(scope,object);
				}
				else
				{
					return callee(arguments[0],arguments[1]);
				}
			}
		};
	return {
		isDefined: function()
		{
			$JSKK.When.captureCondition('isDefined',id,arguments);
			return chain;
		},
		isUndefined: function()
		{
			$JSKK.When.captureCondition('isUndefined',id,arguments);
			return chain;
		},
		isTrue: function()
		{
			$JSKK.When.captureCondition('isTrue',id,arguments);
			return chain;
		},
		isFalse: function()
		{
			$JSKK.When.captureCondition('isFalse',id,arguments);
			return chain;
		},
		isBoolean: function()
		{
			$JSKK.When.captureCondition('isBoolean',id,arguments);
			return chain;
		},
		isFunction: function()
		{
			$JSKK.When.captureCondition('isFunction',id,arguments);
			return chain;
		},
		isArray: function()
		{
			$JSKK.When.captureCondition('isArray',id,arguments);
			return chain;
		},
		isAssocArray: function()
		{
			$JSKK.When.captureCondition('isAssocArray',id,arguments);
			return chain;
		},
		isString: function()
		{
			$JSKK.When.captureCondition('isString',id,arguments);
			return chain;
		},
		isNumber: function()
		{
			$JSKK.When.captureCondition('isNumber',id,arguments);
			return chain;
		},
		isElement: function()
		{
			$JSKK.When.captureCondition('isElement',id,arguments);
			return chain;
		},
		isNull: function()
		{
			$JSKK.When.captureCondition('isNull',id,arguments);
			return chain;
		},
		/**
		 * 
		 * 
$JSKK.when(stores,{object:'count',value:2}).isEqualTo
(
	function()
	{
		...
	}.bind(this)
);
		 * 
		 */
		isEqualTo: function()
		{
			$JSKK.When.captureCondition('isEqualTo',id,arguments);
			return chain;
		},
		isNotEqualTo: function()
		{
			$JSKK.When.captureCondition('isNotEqualTo',id,arguments);
			return chain;
		}
	};
}


/*** TESTING ***/


//window.foobar=false;
//$JSKK.when(window,'foobar').isTrue
//(
//	function(a,b,c)
//	{
//		console.debug(a,b,c);
//	}.bind(this),
//	'arg1',
//	'arg2',
//	'arg3'
//);
//
//$JSKK.Class.create
//(
//	{
//		$namespace:	'foo.bar.baz',
//		$name:		'Foo'
//	}
//)
//(
//	{
//		bar:	null,
//		init:	function()
//		{
//			$JSKK.when(this,'bar').isTrue
//			(
//				function(a,b,c)
//				{
//					console.debug('bar has been set to true!');
//					console.debug(this,a,b,c);
//				}.bind(this),
//				'arg1',
//				'arg2',
//				'arg3'
//			);
//			$JSKK.when(this,'bar').isFalse
//			(
//				function()
//				{
//					console.debug('bar has been set to false!');
//				}
//			);
//			$JSKK.when(this,'baz').isDefined
//			(
//				function()
//				{
//					console.debug('baz has been defined!');
//					console.debug(this.baz);
//				}.bind(this)
//			).andWhen().isDefined
//			(
//				function()
//				{
//					console.debug('baz has been defined![second test(chained)]');
//				}.bind(this)
//			).andWhen().isTrue
//			(
//				function()
//				{
//					console.debug('baz is true!');
//				}.bind(this)
//			);
//			//Simulate adding and removing a variable.
//			window.setTimeout
//			(
//				function()
//				{
//					this.baz='foobarbaz';
//					$JSKK.when(this,'baz').isUndefined
//					(
//						function()
//						{
//							console.debug('baz has been deleted!');
//							console.debug(this.baz);
//						}.bind(this)
//					);
//					window.setTimeout
//					(
//						function()
//						{
//							delete this.baz;
//						}.bind(this),
//						2500
//					);
//				}.bind(this),
//				2500
//			);
//		},
//		setBar: function(val)
//		{
//			this.bar=val;
//		},
//		setBaz: function(val)
//		{
//			this.baz=val;
//		}
//	}
//);
//window.foo=new foo.bar.baz.Foo();
define("When", function(){});

$JSKK.Interface.create
(
	{
		$namespace:	'$JSKK.iface',
		$name:		'Configurable'
	}
)
(
	{
		config:	{}
	}
);
define("iface/Configurable", function(){});

$JSKK.Interface.create
(
	{
		$namespace: '$JSKK.iface',
		$name:		'Observable'
	}
)
(
	{
		events:		[],
		observe:	$JSKK.Interface.METHOD,
		unobserve:	$JSKK.Interface.METHOD,
		fireEvent:	$JSKK.Interface.METHOD
	}
);
define("iface/Observable", function(){});

$JSKK.Trait.create
(
	{
		$namespace:		'$JSKK.trait',
		$name:			'Configurable',
		$implements:	['$JSKK.iface.Configurable']
	}
)
(
	{
		init: function(config)
		{
			Object.extend(this.config,config);
		}
	}
);
define("trait/Configurable", function(){});

$JSKK.Trait.create
(
	{
		$namespace:		'$JSKK.trait',
		$name:			'Observable',
		$implements:	['$JSKK.iface.Observable']
	}
)
(
	{
		init:		function(listeners)
		{
			for (var listener in listeners)
			{
				if (!Object.isFunction(listeners[listener]) && Object.isAssocArray(listeners[listener]))
				{
					if (!Object.isDefined(listeners[listener].callback))
					{
						throw new Error('Invalid observer. Observers defined as objects must specify "callback" as the callback function.');
					}
					else
					{
						if (Object.isDefined(listeners[listener].times))
						{
							this.observeTimes(listeners[listener].times,listener,listeners[listener]);
						}
						else
						{
							this.observe(listener,listeners[listener]);
						}
					}
				}
				else if (Object.isFunction(listeners[listener]))
				{
					this.observe(listener,listeners[listener]);
				}
				else
				{
					throw new Error('Invalid observer. Observers can only be functions.');
				}
			}
		},
		observe:	function(type,listener)
		{
			if (!Object.isArray(this.events[type]))this.events[type]=[];
			if (!Object.isArray(type))type=[type];
			for (var i=0,j=type.length; i<j; i++)
			{
				this.events[type[i]].push(listener);
				this.events[type[i]].last().times=0;
			}
			return this;
		},
		observeOnce: function(type,listener)
		{
			return this.observeTimes.call(this,1,type,listener);
		},
		observeTimes: function(numTimes,type,listener)
		{
			if (!Object.isArray(this.events[type]))this.events[type]=[];
			if (!Object.isArray(type))type=[type];
			for (var i=0,j=type.length; i<j; i++)
			{
				this.events[type[i]].push(listener);
				this.events[type[i]].last().times=numTimes;
			}
			return this;
		},
		unobserve: function(type,listener)
		{
			if (!Object.isArray(type))type=[type];
			for (var i=0,j=type.length; i<j; i++)
			{
				if (!Object.isUndefined(this.events[type[i]]))
				{
					var tmp=[];
					for (var k=0,l=this.events[type[i]].length; k<l; k++)
					{
						if (this.events[type[i]][k]==listener)
						{
							delete this.events[type[i]][k];
						}
						else
						{
							tmp.push(this.events[type[i]][k]);
						}
					}
				}
				this.events[type[i]]=tmp;
				if (!this.events[type[i]].length)this.events[type[i]]=true;
			}
			return this;
		},
		fireEvent: function()
		{
			var	args=$JSKK.toArray(arguments),
				type=args.shift();
			if (!Object.isArray(type))type=[type];
			for (var i=0,j=type.length; i<j; i++)
			{
				if (!Object.isUndefined(this.events[type[i]]) && Object.isArray(this.events[type[i]]))
				{
					for (var k=0,l=this.events[type[i]].length; k<l; k++)
					{
						if (Object.isFunction(this.events[type[i]][k]))
						{
							if (this.events[type[i]][k].apply(this,args)===false)
							{
								return false;
							}
							if (Object.isDefined(this.events[type[i]][k]) && this.events[type[i]][k].times!==0)
							{
								if (--this.events[type[i]][k].times===0)
								{
									this.unobserve(type[i],this.events[type[i]][k]);
								}
							}
						}
					}
				}
			}
			return true;
		},
		clearEvent: function(type)
		{
			if (!Object.isUndefined(this.events[type]))
			{
				this.events[type]=true;
			}
			return this;
		}
	}
);
define("trait/Observable", function(){});

$JSKK.Trait.create
(
	{
		$namespace:	'$JSKK.trait',
		$name:		'Timeable',
		$uses:	'$JSKK.trait.Observable'
	}
)
(
	{
		startTimer: function()
		{
			if (this.config.timeout)
			{
				this.timeout=this.config.timeout;
				window.clearInterval(this.timer);
				this.timer=window.setInterval
				(
					function()
					{
						this.timeout--;
						this.fireEvent('onTimerInterval',this,this.getElapsedTime());
						if (this.timeout<=0)
						{
							window.clearInterval(this.timer);
							this.fireEvent('onTimeout',this);
						}
					}.bind(this),
					1000
				);
			}
		},
		restartTimer: function()
		{
			this.startTimer();
		},
		pauseTimer: function()
		{
			window.clearInterval(this.timer);
		},
		resumeTimer: function()
		{
			this.startTimer();
		},
		stopTimer: function()
		{
			window.clearInterval(this.timer);
			this.timeout=this.config.timeout;
		},
		resetTimer: function()
		{
			this.timeout=this.config.timeout;
		},
		getElapsedTime: function()
		{
			return (this.config.timeout-this.timeout);
		},
		getRemainingTime: function()
		{
			return this.timeout;
		}
	}
);
define("trait/Timeable", function(){});

define
('jskk-optional',
	[
		'./When',
		'./iface/Configurable',
		'./iface/Observable',
		'./trait/Configurable',
		'./trait/Observable',
		'./trait/Timeable'
	]
);